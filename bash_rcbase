#!/bin/bash
# The shebang is just to ensure that Vim knows how to highlight this file.

known_ids="kjstrand BatmanAoD"
id_is_known=false
primary_local_account=''

for usrname in $known_ids; do
    if [[ $usrname == $(whoami) ]]; then
        id_is_known=true
        primary_local_account=$usrname
        primary_HOME=${HOME}
        break
    elif [[ -d $(eval echo ~${usrname} ) ]]; then
        primary_local_account=$usrname
        primary_HOME="$(eval echo ~${usrname})";
    fi
done

# Ensure particular dirs are on $PATH if they exist.
# Logic to ensure path is only added *once* is taken from
# http://superuser.com/a/39995/199803
# For more PATH-editing convenience functions:
# http://superuser.com/a/1001014/199803
ensure_on_path () {
    if [[ -d "$1" ]] && [[ ":$PATH:" != *":$1:"* ]]; then
        export PATH="${PATH:+"$PATH:"}$1"
    fi
}

ensure_on_path "${primary_HOME}/bin"
ensure_on_path "${primary_HOME}/.cargo/bin"

WINDOWS=false
CYGWIN=false
# Alternate:
# if grep -q '_NT-' <(uname -s); then
if [[ -d "$WINDIR" ]]; then
    WINDOWS=true
    # Cygwin-specific oddities
    if grep -q Cygwin <(uname -o); then
        CYGWIN=true
        # Don't get fooled by the carriage-return character.
        export SHELLOPTS
        set -o igncr
        CDPATH=/cygdrive/c/:/cygdrive/c/Users/kjstrand/
    fi
    # TODO: if using Git-Bash, fix `ln`!! (See `install` script)
fi

if [[ -n $primary_local_account ]]; then
    # Check that I have the rest of my "public-config" stuff.
    CONFIG_DIR=${primary_HOME}/public-config
    # TODO consider looking for private-config, too
    alias cfgd_git="git --git-dir $CONFIG_DIR/.git"
    if [[ ! -d $CONFIG_DIR ]]; then
        echo "WARNING: public config directory not found!" >&2
        CONFIG_DIR=
        unalias cfgd_git
    elif grep -v -q -i 'batmanaod' \
    <(cfgd_git config --get remote.origin.url \
    2>/dev/null); then
        echo "WARNING: this bash config designed for use in conjunction" >&2
        echo "with the other config files in the BatmanAoD/public-config" >&2
        echo "git repository." >&2
        unalias cfgd_git
    else
        git_remote_head="$(timeout 1s cfgd_git \
            ls-LINUX_NATIVE origin -h refs/heads/master 2>/dev/null)"
        if [[ -n "$git_remote_head" ]]; then
            if [[ "$(cfgd_git rev-parse HEAD \
                    2>/dev/null)" != \
                "$(echo ${git_remote_head} | awk '{print $1}')" ]]; then
                echo "WARNING: local public config repo is not in sync with github!!" >&2
            fi
        fi
    fi
fi

# If '${primary_HOME}/Public' is empty, delete it. I NEVER use it, and it's mostly just
# annoying.
if [[ -n $CONFIG_DIR && -d ${primary_HOME}/Public && -z $(ls -A ${primary_HOME}/Public) ]]; then
    rmdir ${primary_HOME}/Public
fi

LINUX_ANY=false
if [[ Linux == "$(uname -s)" ]]; then
    LINUX_ANY=true
fi

# Not Windows, not remote, not virtual
check_if_native_linux()
{
    LINUX_NATIVE=$LINUX_ANY;
    $LINUX_NATIVE || return;
    # Are we SSH-ing in?
    grep -qw 'SSH_CLIENT\|SSH_TTY' <(env) && LINUX_NATIVE=false && return;
    # Is this a VM?
    grep -qw hypervisor /proc/cpuinfo && LINUX_NATIVE=false && return;
    # Is Xmodmap usage explicitly disabled? (True for TightVNC connection)
    # TODO any way to check for VNC or RDP protocol automatically?
    test -n "$XKL_XMODMAP_DISABLE" && LINUX_NATIVE=false && return;
}

check_if_native_linux

if $LINUX_NATIVE; then
    # Currently using xmodmap instead of xkbmap
    if [[ -r ${primary_HOME}/.Xmodmap ]]; then
        # TODO why doesn't this seem to work with `reload`?
        xmodmap ${primary_HOME}/.Xmodmap
    else
        echo "WARNING: ${primary_HOME}/.Xmodmap not found!" >&2
    fi
    # TODO check if CAPS is configured, and if so, manually load Xmodmap? (Bug
    # in some WMs...)
    if [[ -f ${primary_HOME}/.Xkbmap ]]; then
        echo "WARNING: Use of ${primary_HOME}/.Xkbmap is deprecated!" >&2
        if [[ -n $CONFIG_DIR ]]; then
            echo "Latest keymapping customizations can be found" >&2
            echo "in $CONFIG_DIR/.Xmodmap" >&2
        fi
    fi
fi

toolsbld_path=${primary_HOME}/ToolsBld

if $id_is_known; then
    mkdir -p ${toolsbld_path}
fi

stderred_path=${toolsbld_path}/stderred

if [[ -d ${stderred_path}  && \
      -r ${stderred_path}/build/libstderred.so && \
      ":$LD_PRELOAD:" != *":${stderred_path}:"* ]]; then
    export LD_PRELOAD="${stderred_path}/build/libstderred.so${LD_PRELOAD:+:$LD_PRELOAD}"
fi

# Do profile if asked.  Used when invoking a shell via remsh, since
# this isnt a bona fide login
test "${DO_PROFILE}" != "" && . ${primary_HOME}/.bash_profile

## Set up CDPATH; this is interesting, but probably dangerous
#export CDPATH=".:${primary_HOME}"

# Set information about the history files
export histchars='!^'  # Get comments saved in history
export HISTSIZE=65536
export HISTFILESIZE=${HISTSIZE}
HISTCONTROL=ignoredups:erasedups
shopt -s histappend
shopt -s checkhash
# Apparently this disables tab-completion for paths. Haha! Uuuuurgh.
# http://stackoverflow.com/q/29907892/1858225
# shopt -s nullglob
# Intentionally duplicated from bashrc
shopt -s extglob
if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then
    shopt -s globstar
    shopt -s autocd
fi

# use Vim as pager.
# Disabled for now because it's actually really annoying.
# TODO: if I can figure out how to get VIM to do colors correctly, then
# I can just implement it myself without all the annoyances built in
# by whoever programmed this thing.
# export PAGER='view -S ${primary_HOME}/.vimpager'
# TODO: make a list of things that bug me about this thing, because I can't
# actually remember why I stopped using it.
#   * numbers not on by default, even though 'set nu' is in vimrc
if [[ -e ${primary_HOME}/bin/vimpager ]]; then
    PAGER=$(readlink -f ${HOMEBIN}/vimpager)
else
  PAGER="less -n -Q"
fi
export PAGER

# Force man pages to be 80 columns wide.
export MANWIDTH=80

# I'd expect there to be a way to do this in my gitconfig, but...maybe not?
export GIT_ASKPASS=

# create a personal-use tmp dir
# Do NOT export! Programs should use the standard `/tmp`!
TMP="${primary_HOME}/tmp"
if $id_is_known; then
    mkdir -p "${primary_HOME}/tmp"
fi

if [[ ! -d "$TMP" ]]; then
    TMP=/tmp
fi

# Set up options
# set -u                # attempting to expand unset variables is an error
set -o monitor          # enable job control
set -o vi               # vi command-line editing

# This is a nice idea, but kind of overly complicated.
# # If one of EDITOR or VISUAL is set to a non-default value, use that value
# # to set the value of the other variable as well.
# DEFAULT_TERMINAL_EDITOR=vim
# DEFAULT_VISUAL_EDITOR="gvim -f"
# DEFAULT_EDITOR_PATTERN="^(vi|$DEFAULT_TERMINAL_EDITOR|$DEFAULT_VISUAL_EDITOR)?\$"
# DEFAULT_VISUAL_PATTERN="^($DEFAULT_TERMINAL_EDITOR|$DEFAULT_VISUAL_EDITOR)?\$"
# if [[ ! $VISUAL =~ $DEFAULT_EDITOR_PATTERN && 
#         $EDITOR =~ $DEFAULT_EDITOR_PATTERN ]]; then
#     echo "Using non-default value for both EDITOR and VISUAL: '$VISUAL'"
#     EDITOR=$VISUAL
# elif [[ ! $EDITOR =~ $DEFAULT_EDITOR_PATTERN && 
#           $VISUAL =~ $DEFAULT_EDITOR_PATTERN ]]; then
#     echo "Using non-default value for both EDITOR and VISUAL: '$EDITOR'"
#     VISUAL=$EDITOR
# elif [[ ! $EDITOR =~ $DEFAULT_EDITOR_PATTERN ]]; then
#     echo "Using non-default values for EDITOR and VISUAL:"
#     echo "EDITOR='$EDITOR'"
#     echo "VISUAL='$VISUAL'"
# fi
# # If VISUAL is still not set, assign my preferred values to both EDITOR and
# # VISUAL.
# if [[ -z $VISUAL ]]; then
#     if [[ -n $DISPLAY ]]; then
#         # always run in foreground unless '&' is used; useful with bash shortcut
#         # to edit command in editor
#         # TODO: make this work with cscope??
#         export VISUAL="gvim -f"
#         export EDITOR="gvim -f"
#     else
#         export VISUAL=vim
#         export EDITOR=vim
#     fi
# fi

# Workaround for a gvim/git-bash oddity.
# See https://stackoverflow.com/q/31167411/1858225
if ! hash gvim 2>/dev/null && type gvim.bat &>/dev/null; then
    alias gvim=gvim.bat
fi
# XXX TODO
# Disable this if I have more problems with neovim!
# TODO - `nvim`, at least on Windows, launches "headless mode",
# with no display at all...not really sure how to get nvim in the
# terminal reliably.
if hash nvim 2>/dev/null; then
    export EDITOR=nvim
    # Custom script for launcing nvim in a new gnome terminal
    # TODO the native GUI interface for nvim will make this unnecessary
    if hash nvim-qt 2>/dev/null && test -n $DISPLAY; then
        # `nvim-qt` and `gvim` both have an odd problem in git-bash
        # that causes them not to fork appropriately.
        # TODO figure out a better condition here.
        if $WINDOWS; then
            export NEWWINDOW_EDIT_CMD="start nvim-qt"
            # Exploit the bug mentioned above.
            # TODO Since this is a bug, it probably isn't reliable...
            export VISUAL=nvim-qt
        else
            export NEWWINDOW_EDIT_CMD=nvim-qt
            # TODO check whether this is supported on Linux yet.
            # export VISUAL="nvim-qt -f"
            export VISUAL=nvim
        fi
    else
        export NEWWINDOW_EDIT_CMD=nvim
        export VISUAL=nvim
    fi
elif hash gvim 2>/dev/null; then
    if [[ -n $DISPLAY ]]; then
        export NEWWINDOW_EDIT_CMD=gvim
        export EDITOR="gvim -f"
        export VISUAL="gvim -f"
    else
        export NEWWINDOW_EDIT_CMD=vim
        export EDITOR=vim
        export VISUAL=vim
    fi
# On Windows, git-bash will install `/usr/bin/vim` -- which is *NOT* what we
# want if we have a full Windows gVim install. Ideally, we could use the
# Windows `start` command to simply check if `gvim` is on the *Windows* PATH,
# then use something like `start /b gvim` as our $NEWWINDOW_EDIT_COMMAND, but
# for some reason the `/b` flag can't be used in git-bash.
# So we simply explicitly check for the `gvim.bat` file in the location that
# the Vim installer happens to use.
# TODO this seems brittle--there's no particular reason for the Vim installer
# to always install the batch files to C:\Windows. Re-evaluate the `start`
# situation and/or try to find another way to search the Windows PATH for gvim.
elif [[ -e "$(cygpath 'C:\Windows\gvim.bat')" ]]; then
    export NEWWINDOW_EDIT_CMD="$(cygpath 'C:\Windows\gvim.bat')"
    export EDITOR="$NEWWINDOW_EDIT_CMD -f"
    export VISUAL="$NEWWINDOW_EDIT_CMD  -f"
else
    # `vi` is universal.
    export NEWWINDOW_EDIT_CMD=vi
    export EDITOR=vi
    export VISUAL=vi
fi


export PEDITOR="$EDITOR"
export EDOVER="$VISUAL"
set -o ignoreeof          # do not let CNTL-D exit the shell
shopt -s checkwinsize    # Reset LINES and COLUMNS after each command

# Inputrc settings to override
bind "set completion-ignore-case on"
bind "set show-all-if-ambiguous on"
bind Space:magic-space # ...for some reason this can't come earlier...?

# Set the prompt
PS1='\h|\W> '    
# Make it cyan
PS1="\[\e[0;36m\]${PS1}\[\e[m\]"
# If root, make that obvious
if [[ $(whoami) == root ]]; then
    PS1="\[\e[0;31m\]\u@\[\e[m\]${PS1}"
elif ! ${id_is_known}; then
    PS1="\[\e[0;33m\]\u@\[\e[m\]${PS1}"
fi
# TODO adopt some of the tricks used for the default git-bash prompt?
# Here is the full prompt variable:
# \[\033]0;$TITLEPREFIX:${PWD//[^[:ascii:]]/?}\007\]\n\[\033[32m\]\u@\h \[\033[35m\]$MSYSTEM \[\033[33m\]\w\[\033[36m\]`__git_ps1`\[\033[0m\]\n$
# Export it
export PS1

# Uncomment the following line to share history in all windows.
# PROMPT_COMMAND="history -a;history -c;history -r"

# Make `less` display colors and not clear the screen
# ....not reeeeeally sure what this does...
# export LESS="-XR"

# Load completion function
if [[ -r /etc/bash_completion ]]; then
     . /etc/bash_completion
     set completion-ignore-case on
fi
