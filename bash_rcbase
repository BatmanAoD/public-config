#!/bin/bash
# The shebang is just to ensure that Vim knows how to highlight this file.

# Set a path to my personal machine.
# TODO make this work.
# This could probably be done by creating a list of "known" machines, 
# ordered by some kind of "priority", and then checking each to see if
# it's accessible on the path, then stopping when I find one.
# Priority probably doesn't matter, since I don't think there will be
# cases when I could potentially find multiple machines I "know".
# For now, use whatever local machine I'm on.
PERSONALMACHINEPATH=

# Ensure my personal $HOME/bin dir is on $PATH.
# Logic to ensure path is only added *once* is taken from
# http://superuser.com/a/39995/199803
# TODO Turn this into a function that can be useable elsewhere, as
# in the original answer!
HOMEBIN=$HOME/bin
if [[ -d "$HOMEBIN" ]] && [[ ":$PATH:" != *":$HOMEBIN:"* ]]; then
    export PATH="${PATH:+"$PATH:"}$HOMEBIN"
fi

CYGWIN=false
if grep -q Cygwin <(uname -o); then
    CYGWIN=true
    # Don't get fooled by the carriage-return character.
    export SHELLOPTS
    set -o igncr
    CDPATH=/cygdrive/c/:/cygdrive/c/Users/kjstrand/
fi

# Check that I have the rest of my "public-config" stuff.
CONFIG_DIR=~/public-config
# TODO consider looking for private-config, too
if [[ ! -d $CONFIG_DIR ]]; then
    echo "WARNING: public config directory not found!" >&2
    CONFIG_DIR=
elif grep -v -q -i 'batmanaod' \
  <(git --git-dir $CONFIG_DIR/.git config --get remote.origin.url \
  2>/dev/null); then
    echo "WARNING: this bash config designed for use in conjunction" >&2
    echo "with the other config files in the BatmanAoD/public-config" >&2
    echo "git repository." >&2
else
    git_remote_head="$(timeout 1s git --git-dir $CONFIG_DIR/.git \
        ls-NATIVE_LINUX origin -h refs/heads/master 2>/dev/null)"
    if [[ -n "$git_remote_head" ]]; then
        if [[ "$(git --git-dir $CONFIG_DIR/.git rev-parse HEAD \
                2>/dev/null)" != \
              "$(echo ${git_remote_head} | awk '{print $1}')" ]]; then
            echo "WARNING: local public config repo is not in sync with github!!" >&2
        fi
    fi
fi

# If '~/Public' is empty, delete it. I NEVER use it, and it's mostly just
# annoying.
if [[ -n $CONFIG_DIR && -d ${HOME}/Public && -z $(ls -A ${HOME}/Public) ]]; then
    rmdir ${HOME}/Public
fi

# Not Cygwin, not remote, not virtual
check_if_native_linux()
{
    NATIVE_LINUX=true;
    # Are we on Cygwin?
    $CYGWIN && NATIVE_LINUX=false && return;
    # Are we SSH-ing in?
    grep -q SSH <(env) && NATIVE_LINUX=false && return;
    # Is this a VirtualBox session?
    grep -q VBOX0 <(xrandr) && NATIVE_LINUX=false && return;
    # ...or a VMWare session?
    # (Other ways to check: http://serverfault.com/q/65718/207703)
    grep -q -i vmware <(lspci) && NATIVE_LINUX=false && return;
    # Is Xmodmap usage explicitly disabled? (True for TightVNC connection)
    test -n "$XKL_XMODMAP_DISABLE" && NATIVE_LINUX=false && return;
}

check_if_native_linux

if $NATIVE_LINUX; then
    # Currently using xmodmap instead of xkbmap
    if [[ -r ~/.Xmodmap ]]; then
        # TODO why doesn't this seem to work with `reload`?
        xmodmap ~/.Xmodmap
    else
        echo "WARNING: ~/.Xmodmap not found!" >&2
    fi
    # TODO check if CAPS is configured, and if so, manually load Xmodmap? (Bug
    # in some WMs...)
    if [[ -f ~/.Xkbmap ]]; then
        echo "WARNING: Use of ~/.Xkbmap is deprecated!" >&2
        if [[ -n $CONFIG_DIR ]]; then
            echo "Latest keymapping customizations can be found" >&2
            echo "in $CONFIG_DIR/.Xmodmap" >&2
        fi
    fi
fi

known_ids="kjstrand BatmanAoD"
can_add_dirs=false

for usrname in $known_ids; do
    if [[ $usrname == $(whoami) ]]; then
        can_add_dirs=true
        break
    fi
done

toolsbld_path=${HOME}/ToolsBld

if $can_add_dirs; then
    mkdir -p ${toolsbld_path}
fi

stderred_path=${toolsbld_path}/stderred

if [[ -d ${stderred_path}  && \
      -r ${stderred_path}/build/libstderred.so && \
      ":$LD_PRELOAD:" != *":${stderred_path}:"* ]]; then
    export LD_PRELOAD="${stderred_path}/build/libstderred.so${LD_PRELOAD:+:$LD_PRELOAD}"
fi

# Do profile if asked.  Used when invoking a shell via remsh, since
# this isnt a bona fide login
test "${DO_PROFILE}" != "" && . ${HOME}/.bash_profile

## Set up CDPATH; this is interesting, but probably dangerous
#export CDPATH=".:~"

# Set information about the history files
export histchars='!^'  # Get comments saved in history
export HISTSIZE=65536
export HISTFILESIZE=${HISTSIZE}
HISTCONTROL=ignoredups:erasedups
shopt -s histappend
shopt -s checkhash
# Apparently this disables tab-completion for paths. Haha! Uuuuurgh.
# http://stackoverflow.com/q/29907892/1858225
# shopt -s nullglob
# Intentionally duplicated from bashrc
shopt -s extglob
if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then
    shopt -s globstar
    shopt -s autocd
fi

# use Vim as pager.
# Disabled for now because it's actually really annoying.
# TODO: if I can figure out how to get VIM to do colors correctly, then
# I can just implement it myself without all the annoyances built in
# by whoever programmed this thing.
# export PAGER='view -S ~/.vimpager'
# TODO: make a list of things that bug me about this thing, because I can't
# actually remember why I stopped using it.
#   * numbers not on by default, even though 'set nu' is in vimrc
if [[ -e ${HOME}/bin/vimpager ]]; then
    PAGER=$(readlink -f ${HOME}/bin/vimpager)
else
  PAGER="less -n -Q"
fi
export PAGER

# Force man pages to be 80 columns wide.
export MANWIDTH=80

# I'd expect there to be a way to do this in my gitconfig, but...maybe not?
export GIT_ASKPASS=

# create a personal-use tmp dir
# Do NOT export! Programs should use the standard `/tmp`!
TMP="$HOME/tmp"
if $can_add_dirs; then
    mkdir -p "$HOME/tmp"
fi

if [[ ! -d "$TMP" ]]; then
    TMP=/tmp
fi

# Set up options
# set -u                # attempting to expand unset variables is an error
set -o monitor          # enable job control
set -o vi               # vi command-line editing

# This is a nice idea, but kind of overly complicated.
# # If one of EDITOR or VISUAL is set to a non-default value, use that value
# # to set the value of the other variable as well.
# DEFAULT_TERMINAL_EDITOR=vim
# DEFAULT_VISUAL_EDITOR="gvim -f"
# DEFAULT_EDITOR_PATTERN="^(vi|$DEFAULT_TERMINAL_EDITOR|$DEFAULT_VISUAL_EDITOR)?\$"
# DEFAULT_VISUAL_PATTERN="^($DEFAULT_TERMINAL_EDITOR|$DEFAULT_VISUAL_EDITOR)?\$"
# if [[ ! $VISUAL =~ $DEFAULT_EDITOR_PATTERN && 
#         $EDITOR =~ $DEFAULT_EDITOR_PATTERN ]]; then
#     echo "Using non-default value for both EDITOR and VISUAL: '$VISUAL'"
#     EDITOR=$VISUAL
# elif [[ ! $EDITOR =~ $DEFAULT_EDITOR_PATTERN && 
#           $VISUAL =~ $DEFAULT_EDITOR_PATTERN ]]; then
#     echo "Using non-default value for both EDITOR and VISUAL: '$EDITOR'"
#     VISUAL=$EDITOR
# elif [[ ! $EDITOR =~ $DEFAULT_EDITOR_PATTERN ]]; then
#     echo "Using non-default values for EDITOR and VISUAL:"
#     echo "EDITOR='$EDITOR'"
#     echo "VISUAL='$VISUAL'"
# fi
# # If VISUAL is still not set, assign my preferred values to both EDITOR and
# # VISUAL.
# if [[ -z $VISUAL ]]; then
#     if [[ -n $DISPLAY ]]; then
#         # always run in foreground unless '&' is used; useful with bash shortcut
#         # to edit command in editor
#         # TODO: make this work with cscope??
#         export VISUAL="gvim -f"
#         export EDITOR="gvim -f"
#     else
#         export VISUAL=vim
#         export EDITOR=vim
#     fi
# fi

# Switch these to use nvim.
# if hash nvim 2>/dev/null; then
if false; then
    export EDITOR=nvim
    # Custom script for launcing nvim in a new gnome terminal
    # TODO the native GUI interface for nvim will make this unnecessary
    if hash NewNvimWindow 2>/dev/null && test -n $DISPLAY; then
        export NEWWINDOW_EDIT_CMD=NewNvimWindow
        # TODO use "-f" with native GUI once support is available
        export VISUAL=nvim
    else
        export NEWWINDOW_EDIT_CMD=nvim
        export VISUAL=nvim
    fi
elif hash gvim 2>/dev/null; then
    if [[ -n $DISPLAY ]]; then
        export NEWWINDOW_EDIT_CMD=gvim
        export EDITOR="gvim -f"
        export VISUAL="gvim -f"
    else
        export NEWWINDOW_EDIT_CMD=vim
        export EDITOR=vim
        export VISUAL=vim
    fi
else
    # `vi` is universal.
    export NEWWINDOW_EDIT_CMD=vi
    export EDITOR=vi
    export VISUAL=vi
fi


export PEDITOR="$EDITOR"
export EDOVER="$VISUAL"
set -o ignoreeof          # do not let CNTL-D exit the shell
shopt -s checkwinsize    # Reset LINES and COLUMNS after each command

# Inputrc settings to override
bind "set completion-ignore-case on"
bind "set show-all-if-ambiguous on"
bind Space:magic-space # ...for some reason this can't come earlier...?

# Set the prompt
PS1='\h|\W> '    
# Make it cyan
PS1="\[\e[0;36m\]${PS1}\[\e[m\]"
# Export it
export PS1

# Uncomment the following line to share history in all windows.
# PROMPT_COMMAND="history -a;history -c;history -r"

# Make `less` display colors and not clear the screen
# ....not reeeeeally sure what this does...
# export LESS="-XR"

# Load completion function
if [[ -r /etc/bash_completion ]]; then
     . /etc/bash_completion
     set completion-ignore-case on
fi

# Default args for compiling C++ programs
CXX_ARGS="-std=c++14 -Wall -Wextra -Wpedantic -isystem"
