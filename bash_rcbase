#!/bin/bash
# The shebang is just to ensure that Vim knows how to highlight this file.

known_ids="kjstrand kstrand BatmanAoD batmanaod"
id_is_known=false
primary_local_account=
primary_HOME=

if [[ -r /usr/libexec/path_helper ]]; then
    # Not sure why this isn't done by default for non-login shells on OS X.
    eval $(/usr/libexec/path_helper)
fi

# Ensure particular dirs are on $PATH if they exist.
# Logic to ensure path is only added *once* is taken from
# http://superuser.com/a/39995/199803
# For more PATH-editing convenience functions:
# http://superuser.com/a/1001014/199803
ensure_on_path () {
    if [[ -d "$1" ]] && [[ ":$PATH:" != *":$1:"* ]]; then
        export PATH="${PATH:+"$PATH:"}$1"
    fi
}

for usrname in $known_ids; do
    if [[ $usrname == $(whoami) ]]; then
        id_is_known=true
        primary_local_account=$usrname
        primary_HOME=${HOME}
        break
    elif [[ -d $(eval echo ~${usrname} ) ]]; then
        primary_local_account=$usrname
        primary_HOME="$(eval echo ~${usrname})";
    fi
done

if [[ -n "$primary_HOME" ]]; then
    ensure_on_path "${primary_HOME}/bin"
    ensure_on_path "${primary_HOME}/.cargo/bin"
fi
# Either way, add the current-user's binaries
ensure_on_path "${HOME}/bin"
ensure_on_path "${HOME}/.cargo/bin"

# TODO move all platform-checking logic to `bootstrap`
WINDOWS=false
CYGWIN=false
WSL=false   # Linux Subsystem on Windows
# See https://stackoverflow.com/a/43618657/1858225
if grep -qE "(Microsoft|WSL)" /proc/version &>/dev/null; then
    # TODO set WINDOWS=true?
    WSL=true
    # TODO check if X11 server is running somehow? (xset? not installed by
    # default...)
    export DISPLAY=:0.0
# Alternate:
# if grep -q '_NT-' <(uname -s); then
elif [[ -d "$WINDIR" ]]; then
    WINDOWS=true
    # Cygwin-specific oddities
    if grep -q Cygwin <(uname -o); then
        CYGWIN=true
        # Don't get fooled by the carriage-return character.
        export SHELLOPTS
        set -o igncr
        CDPATH=/cygdrive/c/:/cygdrive/c/Users/kjstrand/
    fi
    # TODO: if using Git-Bash, fix `ln`!! (See `install` script)
fi

if [[ -n "$primary_HOME" ]]; then
    # Check that I have the rest of my "public-config" stuff.
    CONFIG_DIR="${primary_HOME}/public-config"
    # TODO consider looking for private-config, too
    alias cfgd_git="git --git-dir $CONFIG_DIR/.git"
    if [[ ! -d $CONFIG_DIR ]]; then
        echo "WARNING: public config directory not found!" >&2
        CONFIG_DIR=
        unalias cfgd_git
    elif grep -v -q -i 'batmanaod' \
    <(cfgd_git config --get remote.origin.url \
    2>/dev/null); then
        echo "WARNING: this bash config designed for use in conjunction" >&2
        echo "with the other config files in the BatmanAoD/public-config" >&2
        echo "git repository." >&2
        unalias cfgd_git
    else
        git_remote_head="$(timeout 1s cfgd_git \
            ls-LINUX_NATIVE origin -h refs/heads/master 2>/dev/null)"
        if [[ -n "$git_remote_head" ]]; then
            if [[ "$(cfgd_git rev-parse HEAD \
                    2>/dev/null)" != \
                "$(echo ${git_remote_head} | awk '{print $1}')" ]]; then
                echo "WARNING: local public config repo is not in sync with github!!" >&2
            fi
        fi
    fi
fi

# If '${primary_HOME}/Public' is empty, delete it. I NEVER use it, and it's mostly just
# annoying.
if [[ -n "${primary_HOME}" && -n "$CONFIG_DIR" && -d "${primary_HOME}/Public" && -z $(ls -A "${primary_HOME}/Public") ]]; then
    rmdir "${primary_HOME}/Public"
fi

# LINUX_NATIVE is set in the `bootstrap` script
if $LINUX_NATIVE; then
    if [[ -n "${primary_HOME}" ]]; then
        # Currently using xmodmap instead of xkbmap
        if [[ -r "${primary_HOME}/.Xmodmap" ]]; then
            xmodmap "${primary_HOME}/.Xmodmap"
        else
            echo "WARNING: ${primary_HOME}/.Xmodmap not found!" >&2
        fi
    fi
    # TODO check if CAPS is configured, and if so, manually load Xmodmap? (Bug
    # in some WMs...)
    if [[ -f ${primary_HOME}/.Xkbmap ]]; then
        echo "WARNING: Use of ${primary_HOME}/.Xkbmap is deprecated!" >&2
        if [[ -n $CONFIG_DIR ]]; then
            echo "Latest keymapping customizations can be found" >&2
            echo "in $CONFIG_DIR/.Xmodmap" >&2
        fi
    fi
fi

toolsbld_path=${primary_HOME}/ToolsBld

if $id_is_known; then
    mkdir -p ${toolsbld_path}
fi

stderred_path=${toolsbld_path}/stderred

if [[ -d ${stderred_path}  && \
      -r ${stderred_path}/build/libstderred.so && \
      ":$LD_PRELOAD:" != *":${stderred_path}:"* ]]; then
    export LD_PRELOAD="${stderred_path}/build/libstderred.so${LD_PRELOAD:+:$LD_PRELOAD}"
fi

# Do profile if asked.  Used when invoking a shell via remsh, since
# this isnt a bona fide login
test "${DO_PROFILE}" != "" && . ${primary_HOME}/.bash_profile

## Set up CDPATH; this is interesting, but probably dangerous
#export CDPATH=".:${primary_HOME}"

# Set information about the history files
export histchars='!^'  # Get comments saved in history
export HISTSIZE=65536
export HISTFILESIZE=${HISTSIZE}
HISTCONTROL=ignoredups:erasedups
shopt -s histappend
shopt -s checkhash
# Apparently this disables tab-completion for paths. Haha! Uuuuurgh.
# http://stackoverflow.com/q/29907892/1858225
# shopt -s nullglob
# Intentionally duplicated from bashrc
shopt -s extglob
if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then
    shopt -s globstar
    shopt -s autocd
fi

# use Vim as pager.
# Disabled for now because it's actually really annoying.
# TODO: if I can figure out how to get VIM to do colors correctly, then
# I can just implement it myself without all the annoyances built in
# by whoever programmed this thing.
# export PAGER='view -S ${primary_HOME}/.vimpager'
# TODO: make a list of things that bug me about this thing, because I can't
# actually remember why I stopped using it.
#   * numbers not on by default, even though 'set nu' is in vimrc
if [[ -e ${primary_HOME}/bin/vimpager ]]; then
    PAGER=$(readlink -f ${HOMEBIN}/vimpager)
else
  PAGER="less -n -Q"
fi
export PAGER

# Force man pages to be 80 columns wide.
export MANWIDTH=80

# I'd expect there to be a way to do this in my gitconfig, but...maybe not?
export GIT_ASKPASS=

# create a personal-use tmp dir
# Do NOT export! Programs should use the standard `/tmp`!
TMP="${primary_HOME}/tmp"
if $id_is_known; then
    mkdir -p "${primary_HOME}/tmp"
fi

if [[ ! -d "$TMP" ]]; then
    TMP=/tmp
fi

# Set up options
# set -u                # attempting to expand unset variables is an error
set -o monitor          # enable job control
set -o vi               # vi command-line editing

# Workaround for a gvim/git-bash oddity.
# See https://stackoverflow.com/q/31167411/1858225
if ! hash gvim 2>/dev/null && type gvim.bat &>/dev/null; then
    alias gvim=gvim.bat
fi
# XXX TODO
# Disable this if I have more problems with neovim!
# TODO - `nvim`, at least on Windows, launches "headless mode",
# with no display at all...not really sure how to get nvim in the
# terminal reliably.
if hash nvim 2>/dev/null; then
    export EDITOR=nvim
    # Custom script for launcing nvim in a new gnome terminal
    # TODO the native GUI interface for nvim will make this unnecessary
    if hash nvim-qt 2>/dev/null && test -n $DISPLAY; then
        # `nvim-qt` and `gvim` both have an odd problem in git-bash
        # that causes them not to fork appropriately.
        # TODO figure out a better condition here.
        if $WINDOWS; then
            export NEWWINDOW_EDIT_CMD="start nvim-qt"
            # Exploit the bug mentioned above.
            # TODO Since this is a bug, it probably isn't reliable...
            export VISUAL=nvim-qt
        else
            # Use workaround for https://github.com/equalsraf/neovim-qt/issues/148
            # ...and a weird VcXsrv issue that causes new windows to be gigantic
            export NEWWINDOW_EDIT_CMD="nvim-qt --geometry 650x800 -- --"
            # TODO check whether this is supported on Linux yet.
            # export VISUAL="nvim-qt -f"
            export VISUAL=nvim
        fi
    else
        export NEWWINDOW_EDIT_CMD=nvim
        export VISUAL=nvim
    fi
elif hash gvim 2>/dev/null; then
    # Mac may or may not be running X11.
    if [[ -n $DISPLAY || $MAC_OSX ]]; then
        export NEWWINDOW_EDIT_CMD=gvim
        export EDITOR="gvim -f"
        export VISUAL="gvim -f"
    else
        export NEWWINDOW_EDIT_CMD=vim
        export EDITOR=vim
        export VISUAL=vim
    fi
# On Windows, git-bash will install `/usr/bin/vim` -- which is *NOT* what we
# want if we have a full Windows gVim install. Ideally, we could use the
# Windows `start` command to simply check if `gvim` is on the *Windows* PATH,
# then use something like `start /b gvim` as our $NEWWINDOW_EDIT_COMMAND, but
# for some reason the `/b` flag can't be used in git-bash.
# So we simply explicitly check for the `gvim.bat` file in the location that
# the Vim installer happens to use.
# TODO this seems brittle--there's no particular reason for the Vim installer
# to always install the batch files to C:\Windows. Re-evaluate the `start`
# situation and/or try to find another way to search the Windows PATH for gvim.
elif [[ -e "$(cygpath 'C:\Windows\gvim.bat')" ]]; then
    export NEWWINDOW_EDIT_CMD="$(cygpath 'C:\Windows\gvim.bat')"
    export EDITOR="$NEWWINDOW_EDIT_CMD -f"
    export VISUAL="$NEWWINDOW_EDIT_CMD  -f"
else
    # `vi` is universal.
    export NEWWINDOW_EDIT_CMD=vi
    export EDITOR=vi
    export VISUAL=vi
fi


export PEDITOR="$EDITOR"
export EDOVER="$VISUAL"
set -o ignoreeof          # do not let CNTL-D exit the shell
shopt -s checkwinsize    # Reset LINES and COLUMNS after each command

# Inputrc settings to override
bind "set completion-ignore-case on"
bind "set show-all-if-ambiguous on"
bind Space:magic-space # ...for some reason this can't come earlier...?

# Set the prompt
PS1='\h|\W> '    
# Make it cyan
PS1="\[\e[0;36m\]${PS1}\[\e[m\]"
# If root, make that obvious
if [[ $(whoami) == root ]]; then
    PS1="\[\e[0;31m\]\u@\[\e[m\]${PS1}"
elif ! ${id_is_known}; then
    PS1="\[\e[0;33m\]\u@\[\e[m\]${PS1}"
fi
# TODO adopt some of the tricks used for the default git-bash prompt?
# Here is the full prompt variable:
# \[\033]0;$TITLEPREFIX:${PWD//[^[:ascii:]]/?}\007\]\n\[\033[32m\]\u@\h \[\033[35m\]$MSYSTEM \[\033[33m\]\w\[\033[36m\]`__git_ps1`\[\033[0m\]\n$
# Export it
export PS1

# Uncomment the following line to share history in all windows.
# PROMPT_COMMAND="history -a;history -c;history -r"

# For now, don't run a prompt command.
export PROMPT_COMMAND=

# Make `less` display colors and not clear the screen
# ....not reeeeeally sure what this does...
# export LESS="-XR"

# Figure out the correct RipGrep config file.
# If the parent env has already set a config file path, use that.
if [[ -z "$RIPGREP_CONFIG_PATH" ]]; then
    RIPGREP_CONFIG_PATH="$HOME/.ripgreprc"
    if $WINDOWS; then
        # TODO consider setting this varialbe in Windows environment
        # settings so that it works in cmd.exe.
        RIPGREP_CONFIG_PATH_win="${RIPGREP_CONFIG_PATH}_win"
        if [[ -r "$RIPGREP_CONFIG_PATH_win" ]]; then
            RIPGREP_CONFIG_PATH="$RIPGREP_CONFIG_PATH_win"
        fi
    fi
fi
if [[ -r "$RIPGREP_CONFIG_PATH" ]]; then
    export RIPGREP_CONFIG_PATH
fi

# Load completion function
if [[ -r /etc/bash_completion ]]; then
     . /etc/bash_completion
fi
if [[ -r /usr/local/etc/profile.d/bash_completion.sh ]]; then
    . /usr/local/etc/profile.d/bash_completion.sh
fi
# XXX TEMP - figure out why OS X doesn't seem to have a standard way to install
# git-completions w/ Homebrew
if [[ -r "$HOME/.git-completion.bash" ]]; then
    . "$HOME/.git-completion.bash"
fi
hash kubectl 2>/dev/null && . <(kubectl completion bash)
set completion-ignore-case on
