#!/bin/bash -i
# We run in 'interactive' mode so that we can use settings from .bashrc
# TODO: this causes the weird result that the script actually sources
# `.bashrc`, if it exists.
# This may not be desirable.

# XXX TODO: create a minimal 'bash_bootstrap' file that we can *source* both
# hear and in `.bashrc` for setup that we use here (e.g. the Windows symlink
# function)

echo '$HOME' " is currently $HOME. Press any key to continue or Ctl-C to quit."
if [[ -d "$WINDIR" ]]; then
    WINDOWS=true
    # TODO: don't give this warning unless the `public_config` directory's
    # parent is somewhere other than `$HOME`.
    cat <<WIN_HOME_INSTRUCTIONS
To set the HOME variable to your user-profile directory, manually create
it and assign it to '%USERPROFILE%'.
WIN_HOME_INSTRUCTIONS
    read dummy
    # Windows linking command based on http://stackoverflow.com/a/25394801/1858225
    # TODO this seems like it could be useful in the standard bash setup as well.
    # Ideally, it would be an alias for `ln` that uses the `/h` flag if `-s` is
    # not given as an argument.
    win_symlink() {
        if [[ $# -ne 2 ]]; then
            echo "ERROR: 'win_symlink' requires *two* arguments!" >&2
            # Currently, we *exit* with *error*...because this is a script bug.
            exit 1
        fi
        target="$(cygpath -w ${1})"
        new_link="$(cygpath -w ${2})"
        echo "Making symlink: ${new_link} -> ${target}"
        # Windows needs to be told if it's a directory or not. Infer that.
        # Cygpath should already have performed the directory-separator conversion.
        if [[ -d "$target" ]]; then
            cmd <<< "mklink /D \"$new_link\" \"$target\"" > /dev/null
        else
            cmd <<< "mklink \"$new_link\" \"$target\"" > /dev/null
        fi
    }
    alias universal_symlink=win_symlink
else
    WINDOWS=false
    alias universal_symlink='ln -s'
fi

link_s () {
    if [[ $# -eq 1 ]]; then
        new_link="$(basename "${1}")"
    elif [[ $# -eq 2 ]]; then
        new_link="${2}"
    else
        echo "ERROR: symlink creation requires one or two arguments!" >&2
        # Currently, we *exit* with *error*...because this is a script bug.
        exit 1
    fi
    if [[ -h ${new_link} ]]; then rm ${new_link}; fi
    if [[ -e ${new_link} ]]; then
        echo "ERROR: Can't overwrite non-symlink file: ${new_link}" >&2
    else
        universal_symlink ${1} ${new_link}
    fi
}

# XXX TODO
# Check for `private-config`; if it doesn't exist, prompt to see if there's one
# to clone from Enterprise GitHub (or similar)?

cd ~

shopt -s nullglob

for prog in bash input gdb irb vim zsh git ack ycm; do
    echo Installing rc files for ${prog}
    for file in ~/public-config/${prog}* ~/private-config/${prog}*; do
        if [[ -d ${file} ]]; then continue; fi
        rcname=".$(basename ${file})"
        link_s ${file} ${rcname}
    done
done

if ${WINDOWS}; then
    # TODO change Windows options using Powershell, e.g. show file extensions
    # in Explorer:
    # http://stackoverflow.com/a/8110982/1858225
    link_s .vim vimfiles
    link_s .vimrcbundles _vimrcbundles 
fi

# Use .gitignore globally
# XXX TODO what if git isn't installed yet?
git config --global core.excludesfile ~/.gitignore

mkdir -p ~/bin
cd ~/bin
for prog in ~/public-config/bin/*; do
    basename=$(basename ${prog})
    if [[ ! -e ${basename} ]]; then
        echo Installing ~/bin/${basename}
        link_s ${prog}
    else
        echo ${basename} already installed
    fi
done

if ! ${WINDOWS}; then
    # Linux-specific
    linux_specific=~/public-config/OS_specific/Linux
    
    # Install Xmodmap
    if [[ ! -e ~/.Xmodmap ]]; then
        echo "Installing Xmodmap"
        link_s ${linux_specific}/Xmodmap ~/.Xmodmap
    else
        echo "Xmodmap already exists; not overwriting"
    fi
    
    # Install .i3 config
    mkdir -p ~/.i3
    cd ~/.i3
    if [[ ! -e config ]]; then
        echo Installing i3 config
        link_s "${linux_specific}/i3_config"
        mv i3_config config
    else
        echo i3 config already installed
    fi
fi

##############################################################################
##############################################################################
# CREATE SANDBOX DIRECTORY
##############################################################################
##############################################################################
# XXX TODO
# * Sandbox setup with makefile, inspired by http://stackoverflow.com/a/32485029/1858225
# * To check whether c++14, etc is supported:
# g++ -std=c++14 2>&1 | grep -q 'unrecognized command line'

##############################################################################
##############################################################################
# INSTALL 3RD-PARTY TOOLS
##############################################################################
##############################################################################

if [[ $1 != "--tools" ]]; then
    exit
fi

echo "bashrc is: " ~/.bashrc

. ~/.bashrc

##############################################################################
##############################################################################
# Other git stuff
##############################################################################
##############################################################################
# XXX TODO automatically generate SSH ID and send to GitHub?
##############################################################################

##############################################################################
# Install Vim plugin manager
# (Only if we've installed a nice version of vim--assume that the existence
# of gvim means that this is done.)
if hash gvim 2>/dev/null; then
    plugin_mgr=~/.vim/autoload/plug.vim
    if [[ ! -a ${plugin_mgr} ]]; then
        if hash curl 2>/dev/null; then
            echo Installing Vundle plugins
            curl -fLo ${plugin_mgr} --create-dirs \
                https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
            gvim "+PlugInstall"
        else
            echo "'curl' not installed; not installing Vim-Plug."
        fi
    fi
else
    # TODO `vim-gtk` seems pretty good, generally; just install that?
    echo "WARNING: gvim not installed"
fi

# Install dev tools (Debian-based only)
# TODO: other package managers
# XXX TODO: On Windows, install Chocolatey! This seems like a no-brainer
# obvious win now that I'm working more with Windows.
installusingchoco=false
installusingapt=false
if ${WINDOWS}; then
    # if ! hash choco 2>/dev/null; then
    #     XXX TODO We need an ELEVATED command shell to install Chocolatey.
    #     ...doing the install automatically is probably not worth the hassle.
    #     And indeed by the time we're runing this script, we've already
    #     installed some kind of Bash, which could have been installed using
    #     Chocolatey!
    #     It may be better to just make the Chocolatey install the manual
    #     "first step" for all new machines; the setup would be:
    #       * Open `cmd` as admin
    #       * Run the Chocolatey install-command (below)
    #       * `%ALLUSERSPROFILE%\chocolatey\bin\choco install git.install`
    #       * `%ALLUSERSPROFILE%\chocolatey\bin\choco install conemu`
    #       * Close the `cmd` window, open git bash in conemu, do manual conemu setup
    #           * TODO: conemu setup is stored in `xml`; we could probably
    #             include this as a config file!
    #       * Here in `install`, just check if `choco` is installed.
    #           * If not: print a warning
    #           * If so: install packages
    #     Command to install chocolatey:
    #       @powershell -NoProfile -ExecutionPolicy Bypass -Command "iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))"
    #     Chocolatey bin path is: %ALLUSERSPROFILE%\chocolatey\bin
    # fi
    if hash choco 2>/dev/null; then
        installusingchoco=true
    fi
elif hash apt-get 2>/dev/null; then
    installusingapt=true
fi

# TODO it should be able to unify our package-manager logic.
# * Install commands are always (?) of the form `<pkg-mgr-install> <pkg-name>`
# * We would need to set up a pkg-mgr-install-command function/alias/variable,
#   then have a lookup table for known packages. Then something like:
#       for pkg in $known_pkgs; do
#           # TODO check syntax for assoc-array!!
#           pkg_name="${pkg_names[$mgr][$pkg]}"
#           if [[ -z "$pkg_name" ]]; then continue; fi
#           $pkgmgr_install $pkg_name
#       done

havetoolchain=false
if hash g++ 2>/dev/null; then
    havetoolchain=true;
else
    if hash clang++ 2>/dev/null; then
        havetoolchain=true;
    else
        if $installusingapt; then
            echo Installing build-essential using apt
            sudo apt-get install build-essential
            if [[ $? -eq 0 ]]; then
                havetoolchain=true
            fi
        fi
    fi
fi

havecmake=false
if hash cmake 2>/dev/null; then
    havecmake=true;
else
    if $installusingapt; then
        echo Installing cmake using apt
        sudo apt-get install cmake
        if [[ $? -eq 0 ]]; then
            havecmake=true
        fi
    fi
fi

# Install fzf
if [[ ! -d ~/.fzf ]]; then
    echo Installing fzf
    git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
    # TODO currently, this fails on Windows with MinGW (no prebuilt binary found)
    ~/.fzf/install
fi

# Create installers directory
mkdir -p ~/Installers

# Install rust
if ! hash rustc 2>/dev/null; then
    if ! ${WINDOWS}; then
        echo Installing Rust
        wget -P ~/Installers https://static.rust-lang.org/rustup/dist/x86_64-unknown-linux-gnu/rustup-init
        chmod a+x ~/Installers/rustup-init
        ~/Installers/rustup-init
    fi
    # TODO: on Windows, automatically download and run rustup for windows
else
    echo Checking for Rust updates
    rustup update
fi

# Just in case the above didn't work
if ! hash cargo 2>/dev/null; then
    echo "Can't install rust tools; cargo not installed!" >&2
else
    if ! hash rg 2>/dev/null; then
        echo Installing ripgrep
        cargo install ripgrep
    fi
    if ! hash racer 2>/dev/null; then
        echo Installing racer
        cargo install racer
    fi
    if ! hash loc 2>/dev/null; then
        echo Installing loc
        cargo install loc
    fi
fi

# Install sshrc
if ! hash sshrc 2>/dev/null; then
    echo Installing sshrc
    wget https://raw.githubusercontent.com/Russell91/sshrc/master/sshrc &&
        chmod +x sshrc &&
        sudo mv sshrc ${HOME}/bin
fi

# TODO: install how2? (Not sure how useful it is yet; requires nodejs and some
# fiddling to make it work; specifically, how2 assumes nodejs executable is
# called `node`)

# TODO: other possibly useful command-line tools:
# * eg (easygit) - Simply wget and chmod
# * Stuff from here: http://zeroturnaround.com/rebellabs/5-unexpectedly-useful-command-line-tools-you-might-overlook/
#   * z - remembers common dirs (work with `cd` alias?)
#   * shellcheck - static analysis of Bash for common errors
#   * multitail - better than `tail -F`?
#   * tree - nice recursive dir printing (already installed at work)

# TODO: automatically install windows tools?

# Install stderred
skipstderred=false
if ${WINDOWS}; then
    echo "WINDOWS var is ${WINDOWS}"
    echo "On WINDOWS; not installing stderred."
    skipstderred=true
fi
if ! $havetoolchain; then
    echo "No toolchain installed; not installing stderred."
    skipstderred=true
fi
if ! $havecmake; then
    echo "No cmake installed; not installing stderred."
    skipstderred=true
fi

if ! $skipstderred; then
    if [[ ! -d ${stderred_path} ]]; then
        echo Installing stderred
        cd $(dirname ${stderred_path})
        git clone  https://github.com/sickill/stderred.git
        cd stderred
        make
    fi
fi
