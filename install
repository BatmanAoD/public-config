#!/bin/bash -i
# We run in 'interactive' mode so that we can use settings from .bashrc

echo '$HOME' " is currently $HOME. Press any key to continue or Ctl-C to quit."
if [[ -d "$WINDIR" ]]; then
    WINDOWS=true
    # TODO: don't give this warning unless the `public_config` directory's
    # parent is somewhere other than `$HOME`.
    cat <<WIN_HOME_INSTRUCTIONS
To set the HOME variable to your user-profile directory, manually create
it and assign it to '%USERPROFILE%'.
WIN_HOME_INSTRUCTIONS
    read dummy
    # Windows linking command based on http://stackoverflow.com/a/25394801/1858225
    # TODO this seems like it could be useful in the standard bash setup as well.
    # Ideally, it would be an alias for `ln` that uses the `/h` flag if `-s` is
    # not given as an argument.
    win_symlink() {
        target="$(cygpath -d ${1})"
        if [[ $# -eq 1 ]]; then
            new_link="$(basename "${1}")"
        elif [[ $# -eq 2 ]]; then
            new_link="${2}"
        else
            echo "ERROR: 'win_symlink' requires *two* arguments!" >&2
            # Currently, we *exit* with *error*...because this is a script bug.
            exit 1
        fi
        echo "Making symlink: ${new_link} -> ${target}"
        # Windows needs to be told if it's a directory or not. Infer that.
        # Also: note that we convert `/` to `\`. In this case it's necessary.
        if [[ -d "$target" ]]; then
            cmd <<< "mklink /D \"$new_link\" \"${target//\//\\}\"" > /dev/null
        else
            cmd <<< "mklink \"$new_link\" \"${target//\//\\}\"" > /dev/null
        fi
    }
    alias universal_symlink=win_symlink
else
    WINDOWS=false
    alias universal_symlink='ln -s'
fi

link_s () {
    if [[ -h ${rcname} ]]; then rm ${rcname}; fi
    if [[ -e ${rcname} ]]; then
        echo "ERROR: Can't overwrite non-symlink file: ${rcname}" >&2
    else
        universal_symlink ${file} ${rcname}
    fi
}

cd ~

shopt -s nullglob

for prog in bash input gdb irb vim zsh git ack ycm; do
    echo Installing rc files for ${prog}
    for file in ~/public-config/${prog}* ~/private-config/${prog}*; do
        if [[ -d ${file} ]]; then continue; fi
        rcname=".$(basename ${file})"
        link_s ${file} ${rcname}
    done
done

if ${WINDOWS}; then
    link_s .vimrcbundles _vimrcbundles 
fi

# Use .gitignore globally
# XXX TODO what if git isn't installed yet?
git config --global core.excludesfile ~/.gitignore

mkdir -p ~/bin
cd ~/bin
for prog in ~/public-config/bin/*; do
    basename=$(basename ${prog})
    if [[ ! -e ${basename} ]]; then
        echo Installing ~/bin/${basename}
        link_s ${prog}
    else
        echo ${basename} already installed
    fi
done

if ! ${WINDOWS}; then
    # Linux-specific
    linux_specific=~/public-config/OS_specific/Linux
    
    # Install Xmodmap
    if [[ ! -e ~/.Xmodmap ]]; then
        echo "Installing Xmodmap"
        link_s ${linux_specific}/Xmodmap ~/.Xmodmap
    else
        echo "Xmodmap already exists; not overwriting"
    fi
    
    # Install .i3 config
    mkdir -p ~/.i3
    cd ~/.i3
    if [[ ! -e config ]]; then
        echo Installing i3 config
        link_s "${linux_specific}/i3_config"
        mv i3_config config
    else
        echo i3 config already installed
    fi
fi

##############################################################################
##############################################################################
# CREATE SANDBOX DIRECTORY
##############################################################################
##############################################################################
# XXX TODO
# * Sandbox setup with makefile, inspired by http://stackoverflow.com/a/32485029/1858225
# * To check whether c++14, etc is supported:
# g++ -std=c++14 2>&1 | grep -q 'unrecognized command line'

##############################################################################
##############################################################################
# INSTALL 3RD-PARTY TOOLS
##############################################################################
##############################################################################

if [[ $1 != "--tools" ]]; then
    exit
fi

echo "bashrc is: " ~/.bashrc

. ~/.bashrc

##############################################################################
##############################################################################
# Other git stuff
##############################################################################
##############################################################################
# XXX TODO automatically generate SSH ID and send to GitHub?
##############################################################################

##############################################################################
# Install Vundle
vundle_bundle=~/.vim/bundle/Vundle.vim
if [[ ! -a ${vundle_bundle} ]]; then
    echo Installing Vundle plugins
    git clone https://github.com/gmarik/Vundle.vim.git ${vundle_bundle}
    vim "+BundleInstall" "+qa"
fi

# Install dev tools (Debian-based only)
# TODO: other package managers
if hash apt-get 2>/dev/null; then
    installusingapt=true
else
    installusingapt=false
fi

havetoolchain=false
if hash g++ 2>/dev/null; then
    havetoolchain=true;
else
    if hash clang++ 2>/dev/null; then
        havetoolchain=true;
    else
        if $installusingapt; then
            echo Installing build-essential using apt
            sudo apt-get install build-essential
            if [[ $? -eq 0 ]]; then
                havetoolchain=true
            fi
        fi
    fi
fi

havecmake=false
if hash cmake 2>/dev/null; then
    havecmake=true;
else
    if $installusingapt; then
        echo Installing cmake using apt
        sudo apt-get install cmake
        if [[ $? -eq 0 ]]; then
            havecmake=true
        fi
    fi
fi

# Install fzf
if [[ ! -d ~/.fzf ]]; then
    echo Installing fzf
    git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
    # TODO currently, this fails on Windows with MinGW (no prebuilt binary found)
    ~/.fzf/install
fi

# Create installers directory
mkdir -p ~/Installers

# Install rust
if ! hash rustc 2>/dev/null; then
    if ! ${WINDOWS}; then
        echo Installing Rust
        wget -P ~/Installers https://static.rust-lang.org/rustup/dist/x86_64-unknown-linux-gnu/rustup-init
        chmod a+x ~/Installers/rustup-init
        ~/Installers/rustup-init
    fi
    # TODO: on Windows, automatically download and run rustup for windows
else
    echo Checking for Rust updates
    rustup update
fi

# Just in case the above didn't work
if ! hash cargo 2>/dev/null; then
    echo "Can't install rust tools; cargo not installed!" >&2
else
    if ! hash rg 2>/dev/null; then
        echo Installing ripgrep
        cargo install ripgrep
    fi
    if ! hash racer 2>/dev/null; then
        echo Installing racer
        cargo install racer
    fi
    if ! hash loc 2>/dev/null; then
        echo Installing loc
        cargo install loc
    fi
fi

# Install sshrc
if ! hash sshrc 2>/dev/null; then
    echo Installing sshrc
    wget https://raw.githubusercontent.com/Russell91/sshrc/master/sshrc &&
        chmod +x sshrc &&
        sudo mv sshrc ${HOME}/bin
fi

# TODO: install how2? (Not sure how useful it is yet; requires nodejs and some
# fiddling to make it work; specifically, how2 assumes nodejs executable is
# called `node`)

# TODO: other possibly useful command-line tools:
# * eg (easygit) - Simply wget and chmod
# * Stuff from here: http://zeroturnaround.com/rebellabs/5-unexpectedly-useful-command-line-tools-you-might-overlook/
#   * z - remembers common dirs (work with `cd` alias?)
#   * shellcheck - static analysis of Bash for common errors
#   * multitail - better than `tail -F`?
#   * tree - nice recursive dir printing (already installed at work)

# TODO: automatically install windows tools?

# Install stderred
skipstderred=false
if ${WINDOWS}; then
    echo "WINDOWS var is ${WINDOWS}"
    echo "On WINDOWS; not installing stderred."
    skipstderred=true
fi
if ! $havetoolchain; then
    echo "No toolchain installed; not installing stderred."
    skipstderred=true
fi
if ! $havecmake; then
    echo "No cmake installed; not installing stderred."
    skipstderred=true
fi

if ! $skipstderred; then
    if [[ ! -d ${stderred_path} ]]; then
        echo Installing stderred
        cd $(dirname ${stderred_path})
        git clone git://github.com/sickill/stderred.git
        cd stderred
        make
    fi
fi
